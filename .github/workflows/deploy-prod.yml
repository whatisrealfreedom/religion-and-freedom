name: Deploy to Production

on:
  push:
    branches:
      - main
  workflow_dispatch:

env:
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Prepare files for deployment
        run: |
          # Wait a moment to ensure git checkout is fully complete
          # This prevents "file changed as we read it" warnings from git metadata updates
          sleep 1

          # Create tar archive excluding large files and build artifacts
          # Note: "file changed as we read it" warning can occur in CI when:
          # - Git is still updating file timestamps/metadata after checkout
          # - File system caching delays in virtualized environments
          # This warning is harmless - the archive is still valid
          set +e  # Don't exit on error
          tar --exclude='.git' \
            --exclude='node_modules' \
            --exclude='frontend/node_modules' \
            --exclude='frontend/build' \
            --exclude='backend/cmd/server/server' \
            --exclude='backend/server' \
            --exclude='data' \
            --exclude='.env*' \
            --exclude='.DS_Store' \
            --exclude='__pycache__' \
            --exclude='*.pyc' \
            --exclude='*.db' \
            --exclude='*.db-shm' \
            --exclude='*.db-wal' \
            -czf deploy.tar.gz . 2>&1
          TAR_EXIT=$?
          # Exit code 1 from tar is often just warnings, check if file was created
          if [ $TAR_EXIT -ne 0 ] && [ ! -f deploy.tar.gz ]; then
            echo "‚ùå tar failed and no archive was created"
            exit 1
          fi
          echo "‚úÖ Archive created successfully"
          set -e  # Re-enable exit on error

      - name: Prepare server directory
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USERNAME }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            mkdir -p /home/${{ secrets.SERVER_USERNAME }}/freedom-website

      - name: Check archive size
        run: |
          ARCHIVE_SIZE=$(stat -f%z deploy.tar.gz 2>/dev/null || stat -c%s deploy.tar.gz 2>/dev/null)
          ARCHIVE_SIZE_MB=$((ARCHIVE_SIZE / 1024 / 1024))
          echo "üì¶ Archive size: ${ARCHIVE_SIZE_MB}MB (${ARCHIVE_SIZE} bytes)"
          if [ $ARCHIVE_SIZE_MB -gt 500 ]; then
            echo "‚ö†Ô∏è  Archive is very large, this might cause timeout issues"
          fi

      - name: Copy archive to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USERNAME }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          source: "deploy.tar.gz"
          target: "/home/${{ secrets.SERVER_USERNAME }}/freedom-website"
          strip_components: 0
          rm: false
          debug: true
          timeout: 300s
          command_timeout: 10m

      - name: Extract files on server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USERNAME }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            cd /home/${{ secrets.SERVER_USERNAME }}/freedom-website
            if [ -f deploy.tar.gz ]; then
              echo "‚úÖ Archive found, extracting..."
              tar -xzf deploy.tar.gz || (echo "‚ùå Extraction failed" && exit 1)
              rm deploy.tar.gz
              echo "‚úÖ Files extracted successfully"
              ls -la | head -20
            else
              echo "‚ùå deploy.tar.gz not found in target directory!"
              echo "Contents of directory:"
              ls -la
              exit 1
            fi

      - name: Deploy on server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USERNAME }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            cd /home/${{ secrets.SERVER_USERNAME }}/freedom-website

            # Copy .env.prod from existing location
            # Configure ENV_SOURCE_PATH in GitHub Secrets if needed
            ENV_SOURCE_PATH="${ENV_SOURCE_PATH:-/home/${{ secrets.SERVER_USERNAME }}/freedom/.env.prod}"
            if [ -f "$ENV_SOURCE_PATH" ]; then
              echo "‚úÖ Copying .env.prod"
              cp "$ENV_SOURCE_PATH" .env
            else
              echo "‚ö†Ô∏è  .env.prod not found"
              echo "‚ö†Ô∏è  Please create .env file manually with DOMAIN_FREEDOM and TRAEFIK_NETWORK"
              exit 1
            fi

            # Load environment variables from .env
            if [ -f .env ]; then
              set -a
              source .env
              set +a
              echo "‚úÖ Loaded .env"
            else
              echo "‚ùå .env not found!"
              exit 1
            fi

            # Export environment variables for docker-compose
            export DOMAIN_FREEDOM=${DOMAIN_FREEDOM}
            export TRAEFIK_NETWORK=${TRAEFIK_NETWORK:-traefik-network}

            # Build images
            echo "üî® Building images..."
            docker-compose -f docker-compose.prod.yml build

            # Start containers
            echo "üöÄ Starting containers..."
            docker-compose -f docker-compose.prod.yml up -d

            # Wait for backend to be ready
            echo "‚è≥ Waiting for backend to start..."
            sleep 5

            # Check status
            echo "üìä Container status:"
            docker-compose -f docker-compose.prod.yml ps

            # Check logs
            echo "üìã Recent logs:"
            docker-compose -f docker-compose.prod.yml logs --tail=20

            # Clean up old images
            echo "üßπ Cleaning up old images..."
            docker image prune -f
